package com.wenchukai.durable.core.impl;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.sql.DataSource;

import com.wenchukai.durable.bean.Beaninfo;
import com.wenchukai.durable.config.BeaninfoCfg;
import com.wenchukai.durable.core.Execute;

public class ExecuteImpl implements Execute {

	@Resource
	private DataSource dataSource;

	public ExecuteImpl() {
	}

	/**
	 * ͨ获取预编译对象
	 * 
	 * @param connection
	 * 
	 * @param sql
	 * 
	 * @param params
	 * @param connection
	 * 
	 * @return preparedStatement
	 * @throws SQLException
	 */
	private PreparedStatement getPreparedStatement(String sql, Object[] params, Connection connection,
			int autoGeneratedKey) throws SQLException {
		PreparedStatement ps = connection.prepareStatement(sql, autoGeneratedKey);
		if (params != null) {
			for (int i = 0; i < params.length; i++) {
				ps.setObject(i + 1, params[i]);
			}
		}
		return ps;
	}

	/**
	 * 修改方法
	 * 
	 * @param sql
	 * @param params
	 * @return 受影响的行数
	 * @throws SQLException
	 */
	public int executeUpdate(String sql, Object[] params) {
		int count = 0;
		PreparedStatement ps = null;
		// 从连接池获取连接
		try {
			Connection connection = getConnection();
			ps = getPreparedStatement(sql, params, connection, -1);
			count = ps.executeUpdate();
			this.closeConnection(connection);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return count;
	}

	/**
	 * 查询
	 * 
	 * @param sql
	 * @param params
	 *            Object[]
	 * @return 结果集
	 * @throws SQLException
	 */
	public <T> List<T> executeQuery(String sql, Object[] params, Class<T> beanClass) {
		PreparedStatement ps = null;
		try {
			Connection connection = getConnection();
			ps = this.getPreparedStatement(sql, params, connection, Statement.NO_GENERATED_KEYS);
			return convertResultSet(ps.executeQuery(), connection, beanClass);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return new ArrayList<T>();
	}

	public DataSource getDataSource() {
		return dataSource;
	}

	public void setDataSource(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	/**
	 * 将结果集封装为Bean对象
	 * 
	 * @param rs
	 * @param connection
	 * @param beanClass
	 * @return
	 */
	private <T> List<T> convertResultSet(ResultSet sqlRs, Connection connection, Class<T> beanClass) {
		Beaninfo beaninfo = BeaninfoCfg.BEANINFO_CFG.getBeaninfo(beanClass);
		Map<String, Method> map = beaninfo.getSetMethodMap();
		List<T> list = new ArrayList<T>();
		try {
			while (sqlRs.next()) {
				T entity = beanClass.newInstance();
				// 获取行数据
				ResultSetMetaData metaData = sqlRs.getMetaData();
				int colNum = metaData.getColumnCount();
				for (int i = 1; i <= colNum; i++) {
					// 遍历行，获取列名
					String name = metaData.getColumnName(i);
					Method method = map.get(name.toLowerCase());
					if (method == null) {
						continue;
					}
					setValue(entity, method, (Class<?>) method.getGenericParameterTypes()[0], sqlRs.getObject(i));
				}
				list.add(entity);
			}
		} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException
				| ClassNotFoundException | SQLException e) {
			e.printStackTrace();
		} finally {
			this.closeConnection(connection);
		}
		return list;
	}

	/**
	 * 反射注入值
	 */
	private <T> void setValue(T entity, Method method, Class<?> type, Object val)
			throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, ClassNotFoundException {
		if (val == null) {
			method.invoke(entity, val);
		} else if (type.isAssignableFrom(String.class)) {
			method.invoke(entity, val.toString());
		} else if (type.isAssignableFrom(Integer.class)) {
			Integer i = (Integer) val;
			method.invoke(entity, i);
		} else if (type.isAssignableFrom(LocalDateTime.class)) {
			method.invoke(entity, ((Timestamp) val).toLocalDateTime());
		} else if (type.isAssignableFrom(long.class)) {
			method.invoke(entity, (Long) val);
		} else if (type.isAssignableFrom(int.class)) {
			method.invoke(entity, ((Long) val).intValue());
		} else {
			throw new ClassNotFoundException(type.toString());
		}

	}

	/**
	 * 自动提交时才能随意关闭连接
	 * 
	 * @param connection
	 */
	public void closeConnection(Connection connection) {
		try {
			if (connection.getAutoCommit() && connection != null && !connection.isClosed()) {
				connection.close();
				CONNECTION_THREAD_LOCAL.remove();
			}
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}

	@Override
	public Connection getConnection() {
		Connection connection = CONNECTION_THREAD_LOCAL.get();
		if (connection != null) {
			return connection;
		}
		try {
			connection = this.getDataSource().getConnection();
		} catch (SQLException e) {
			e.printStackTrace();
		}
		CONNECTION_THREAD_LOCAL.set(connection);
		return connection;
	}

	@Override
	public Integer executeInsert(String sql, Object[] params) {
		Object key = null;
		PreparedStatement ps = null;
		// 从连接池获取连接
		try {
			Connection connection = getConnection();
			ps = getPreparedStatement(sql, params, connection, Statement.RETURN_GENERATED_KEYS);
			ps.executeUpdate();
			ResultSet rs = ps.getGeneratedKeys();
			if (rs.next()) {
				key = rs.getObject(1);
			}
			this.closeConnection(connection);
		} catch (SQLException e) {
			e.printStackTrace();
		}
		return key != null ? ((Long) key).intValue() : null;
	}

}
